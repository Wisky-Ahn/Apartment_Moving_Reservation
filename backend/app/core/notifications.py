"""
ÏóêÎü¨ ÏïåÎ¶º ÏãúÏä§ÌÖú
Ï§ëÏöîÌïú ÏóêÎü¨ Î∞úÏÉù Ïãú Í¥ÄÎ¶¨ÏûêÏóêÍ≤å ÏïåÎ¶ºÏùÑ Î≥¥ÎÇ¥Îäî ÏãúÏä§ÌÖú
"""
import asyncio
import smtplib
import json
from typing import Dict, Any, List, Optional
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime, timedelta
from enum import Enum
import aiohttp
import logging

from app.core.config import settings


logger = logging.getLogger(__name__)


class NotificationLevel(str, Enum):
    """ÏïåÎ¶º Î†àÎ≤® Ï†ïÏùò"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class NotificationChannel(str, Enum):
    """ÏïåÎ¶º Ï±ÑÎÑê Ï†ïÏùò"""
    EMAIL = "email"
    SLACK = "slack"
    WEBHOOK = "webhook"
    SMS = "sms"  # Ìñ•ÌõÑ Íµ¨ÌòÑ


class ErrorAlert:
    """ÏóêÎü¨ ÏïåÎ¶º Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞"""
    
    def __init__(
        self,
        title: str,
        message: str,
        level: NotificationLevel,
        error_code: str = None,
        request_id: str = None,
        user_info: Dict[str, Any] = None,
        context: Dict[str, Any] = None,
        timestamp: datetime = None
    ):
        self.title = title
        self.message = message
        self.level = level
        self.error_code = error_code
        self.request_id = request_id
        self.user_info = user_info or {}
        self.context = context or {}
        self.timestamp = timestamp or datetime.utcnow()
    
    def to_dict(self) -> Dict[str, Any]:
        """ÎîïÏÖîÎÑàÎ¶¨ ÌòïÌÉúÎ°ú Î≥ÄÌôò"""
        return {
            "title": self.title,
            "message": self.message,
            "level": self.level.value,
            "error_code": self.error_code,
            "request_id": self.request_id,
            "user_info": self.user_info,
            "context": self.context,
            "timestamp": self.timestamp.isoformat()
        }


class NotificationRateLimiter:
    """
    ÏïåÎ¶º Î∞úÏÜ° ÎπàÎèÑ Ï†úÌïú
    Í∞ôÏùÄ ÏóêÎü¨Í∞Ä Î∞òÎ≥µÏ†ÅÏúºÎ°ú Î∞úÏÉùÌï† Îïå Ïä§Ìå∏ Î∞©ÏßÄ
    """
    
    def __init__(self):
        self._alerts: Dict[str, datetime] = {}
        self._cooldown_minutes = {
            NotificationLevel.CRITICAL: 5,   # 5Î∂Ñ
            NotificationLevel.HIGH: 15,      # 15Î∂Ñ
            NotificationLevel.MEDIUM: 60,    # 1ÏãúÍ∞Ñ
            NotificationLevel.LOW: 240       # 4ÏãúÍ∞Ñ
        }
    
    def should_send(self, alert: ErrorAlert) -> bool:
        """ÏïåÎ¶ºÏùÑ Î≥¥ÎÇºÏßÄ Í≤∞Ï†ï"""
        # ÏïåÎ¶º ÌÇ§ ÏÉùÏÑ± (ÏóêÎü¨ ÏΩîÎìú + Î†àÎ≤®)
        alert_key = f"{alert.error_code}_{alert.level.value}"
        
        # ÎßàÏßÄÎßâ ÏïåÎ¶º ÏãúÍ∞Ñ ÌôïÏù∏
        last_sent = self._alerts.get(alert_key)
        if not last_sent:
            self._alerts[alert_key] = alert.timestamp
            return True
        
        # Ïø®Îã§Ïö¥ ÏãúÍ∞Ñ ÌôïÏù∏
        cooldown_minutes = self._cooldown_minutes.get(alert.level, 60)
        time_diff = alert.timestamp - last_sent
        
        if time_diff.total_seconds() >= (cooldown_minutes * 60):
            self._alerts[alert_key] = alert.timestamp
            return True
        
        return False
    
    def reset_alerts(self):
        """ÏïåÎ¶º Í∏∞Î°ù Ï¥àÍ∏∞Ìôî (ÌÖåÏä§Ìä∏Ïö©)"""
        self._alerts.clear()


class BaseNotificationHandler:
    """ÏïåÎ¶º Ìï∏Îì§Îü¨ Í∏∞Î≥∏ ÌÅ¥ÎûòÏä§"""
    
    async def send(self, alert: ErrorAlert) -> bool:
        """ÏïåÎ¶º Î∞úÏÜ° (ÏÑúÎ∏åÌÅ¥ÎûòÏä§ÏóêÏÑú Íµ¨ÌòÑ)"""
        raise NotImplementedError
    
    def format_message(self, alert: ErrorAlert) -> str:
        """ÏïåÎ¶º Î©îÏãúÏßÄ Ìè¨Îß∑ÌåÖ"""
        return f"""
üö® **{alert.title}** [{alert.level.value.upper()}]

**Message:** {alert.message}
**Time:** {alert.timestamp.strftime('%Y-%m-%d %H:%M:%S UTC')}
**Error Code:** {alert.error_code or 'N/A'}
**Request ID:** {alert.request_id or 'N/A'}

**User Info:**
{json.dumps(alert.user_info, indent=2) if alert.user_info else 'None'}

**Context:**
{json.dumps(alert.context, indent=2) if alert.context else 'None'}
        """.strip()


class EmailNotificationHandler(BaseNotificationHandler):
    """Ïù¥Î©îÏùº ÏïåÎ¶º Ìï∏Îì§Îü¨"""
    
    def __init__(
        self,
        smtp_server: str,
        smtp_port: int,
        username: str,
        password: str,
        from_email: str,
        to_emails: List[str]
    ):
        self.smtp_server = smtp_server
        self.smtp_port = smtp_port
        self.username = username
        self.password = password
        self.from_email = from_email
        self.to_emails = to_emails
    
    async def send(self, alert: ErrorAlert) -> bool:
        """Ïù¥Î©îÏùº ÏïåÎ¶º Î∞úÏÜ°"""
        try:
            # Ïù¥Î©îÏùº Î©îÏãúÏßÄ Íµ¨ÏÑ±
            msg = MIMEMultipart()
            msg['From'] = self.from_email
            msg['To'] = ', '.join(self.to_emails)
            msg['Subject'] = f"[FNM Alert] {alert.title} [{alert.level.value.upper()}]"
            
            # HTML Î≤ÑÏ†ÑÍ≥º ÌÖçÏä§Ìä∏ Î≤ÑÏ†Ñ ÏÉùÏÑ±
            html_body = self._create_html_message(alert)
            text_body = self.format_message(alert)
            
            msg.attach(MIMEText(text_body, 'plain'))
            msg.attach(MIMEText(html_body, 'html'))
            
            # SMTP ÏÑúÎ≤ÑÎ•º ÌÜµÌï¥ Ïù¥Î©îÏùº Î∞úÏÜ°
            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                server.starttls()
                server.login(self.username, self.password)
                server.send_message(msg)
            
            logger.info(f"Email alert sent successfully: {alert.title}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to send email alert: {e}")
            return False
    
    def _create_html_message(self, alert: ErrorAlert) -> str:
        """HTML ÌòïÌÉúÏùò Ïù¥Î©îÏùº Î©îÏãúÏßÄ ÏÉùÏÑ±"""
        level_colors = {
            NotificationLevel.CRITICAL: "#dc3545",
            NotificationLevel.HIGH: "#fd7e14", 
            NotificationLevel.MEDIUM: "#ffc107",
            NotificationLevel.LOW: "#17a2b8"
        }
        
        color = level_colors.get(alert.level, "#6c757d")
        
        return f"""
        <html>
        <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <div style="background-color: {color}; color: white; padding: 20px; border-radius: 5px 5px 0 0;">
                <h2 style="margin: 0;">üö® {alert.title}</h2>
                <span style="background-color: rgba(255,255,255,0.2); padding: 5px 10px; border-radius: 3px; font-size: 12px;">
                    {alert.level.value.upper()}
                </span>
            </div>
            
            <div style="background-color: #f8f9fa; padding: 20px; border-radius: 0 0 5px 5px;">
                <h3>Message</h3>
                <p style="background-color: white; padding: 15px; border-left: 4px solid {color};">
                    {alert.message}
                </p>
                
                <table style="width: 100%; border-collapse: collapse; margin-top: 20px;">
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid #dee2e6; font-weight: bold;">Time:</td>
                        <td style="padding: 8px; border-bottom: 1px solid #dee2e6;">{alert.timestamp.strftime('%Y-%m-%d %H:%M:%S UTC')}</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid #dee2e6; font-weight: bold;">Error Code:</td>
                        <td style="padding: 8px; border-bottom: 1px solid #dee2e6;">{alert.error_code or 'N/A'}</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid #dee2e6; font-weight: bold;">Request ID:</td>
                        <td style="padding: 8px; border-bottom: 1px solid #dee2e6;">{alert.request_id or 'N/A'}</td>
                    </tr>
                </table>
                
                {self._format_json_section("User Info", alert.user_info)}
                {self._format_json_section("Context", alert.context)}
            </div>
        </body>
        </html>
        """
    
    def _format_json_section(self, title: str, data: Dict[str, Any]) -> str:
        """JSON Îç∞Ïù¥ÌÑ∞Î•º HTML ÏÑπÏÖòÏúºÎ°ú Ìè¨Îß∑ÌåÖ"""
        if not data:
            return ""
        
        return f"""
        <div style="margin-top: 20px;">
            <h4>{title}</h4>
            <pre style="background-color: white; padding: 15px; border: 1px solid #dee2e6; border-radius: 3px; overflow-x: auto;">
{json.dumps(data, indent=2)}
            </pre>
        </div>
        """


class SlackNotificationHandler(BaseNotificationHandler):
    """Slack ÏïåÎ¶º Ìï∏Îì§Îü¨"""
    
    def __init__(self, webhook_url: str, channel: str = None):
        self.webhook_url = webhook_url
        self.channel = channel
    
    async def send(self, alert: ErrorAlert) -> bool:
        """Slack ÏïåÎ¶º Î∞úÏÜ°"""
        try:
            # Slack Î©îÏãúÏßÄ ÌéòÏù¥Î°úÎìú Íµ¨ÏÑ±
            payload = {
                "text": f"üö® {alert.title}",
                "attachments": [
                    {
                        "color": self._get_color(alert.level),
                        "fields": [
                            {
                                "title": "Level",
                                "value": alert.level.value.upper(),
                                "short": True
                            },
                            {
                                "title": "Error Code",
                                "value": alert.error_code or "N/A",
                                "short": True
                            },
                            {
                                "title": "Request ID", 
                                "value": alert.request_id or "N/A",
                                "short": True
                            },
                            {
                                "title": "Time",
                                "value": alert.timestamp.strftime('%Y-%m-%d %H:%M:%S UTC'),
                                "short": True
                            },
                            {
                                "title": "Message",
                                "value": alert.message,
                                "short": False
                            }
                        ],
                        "footer": "FNM Error Alert System",
                        "ts": int(alert.timestamp.timestamp())
                    }
                ]
            }
            
            if self.channel:
                payload["channel"] = self.channel
            
            # Ï∂îÍ∞Ä Ï†ïÎ≥¥Í∞Ä ÏûàÏúºÎ©¥ Ìè¨Ìï®
            if alert.user_info or alert.context:
                additional_info = []
                if alert.user_info:
                    additional_info.append(f"**User Info:**\n```{json.dumps(alert.user_info, indent=2)}```")
                if alert.context:
                    additional_info.append(f"**Context:**\n```{json.dumps(alert.context, indent=2)}```")
                
                payload["attachments"][0]["fields"].append({
                    "title": "Additional Info",
                    "value": "\n\n".join(additional_info),
                    "short": False
                })
            
            # Slack WebhookÏúºÎ°ú POST ÏöîÏ≤≠
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    self.webhook_url,
                    json=payload,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    if response.status == 200:
                        logger.info(f"Slack alert sent successfully: {alert.title}")
                        return True
                    else:
                        logger.error(f"Slack webhook returned status {response.status}")
                        return False
                        
        except Exception as e:
            logger.error(f"Failed to send Slack alert: {e}")
            return False
    
    def _get_color(self, level: NotificationLevel) -> str:
        """ÏïåÎ¶º Î†àÎ≤®Ïóê Îî∞Î•∏ ÏÉâÏÉÅ Î∞òÌôò"""
        colors = {
            NotificationLevel.CRITICAL: "danger",
            NotificationLevel.HIGH: "warning",
            NotificationLevel.MEDIUM: "#ffc107",
            NotificationLevel.LOW: "good"
        }
        return colors.get(level, "#6c757d")


class WebhookNotificationHandler(BaseNotificationHandler):
    """ÏõπÌõÖ ÏïåÎ¶º Ìï∏Îì§Îü¨"""
    
    def __init__(self, webhook_url: str, headers: Dict[str, str] = None):
        self.webhook_url = webhook_url
        self.headers = headers or {"Content-Type": "application/json"}
    
    async def send(self, alert: ErrorAlert) -> bool:
        """ÏõπÌõÖ ÏïåÎ¶º Î∞úÏÜ°"""
        try:
            payload = alert.to_dict()
            
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    self.webhook_url,
                    json=payload,
                    headers=self.headers,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    if 200 <= response.status < 300:
                        logger.info(f"Webhook alert sent successfully: {alert.title}")
                        return True
                    else:
                        logger.error(f"Webhook returned status {response.status}")
                        return False
                        
        except Exception as e:
            logger.error(f"Failed to send webhook alert: {e}")
            return False


class NotificationManager:
    """
    ÏïåÎ¶º Í¥ÄÎ¶¨Ïûê
    Ïó¨Îü¨ Ï±ÑÎÑêÏùÑ ÌÜµÌï¥ ÏïåÎ¶ºÏùÑ Î∞úÏÜ°ÌïòÍ≥† ÎπàÎèÑÎ•º Ï†úÌïú
    """
    
    def __init__(self):
        self.handlers: Dict[NotificationChannel, BaseNotificationHandler] = {}
        self.rate_limiter = NotificationRateLimiter()
        self.enabled_levels: List[NotificationLevel] = [
            NotificationLevel.HIGH,
            NotificationLevel.CRITICAL
        ]
    
    def add_handler(self, channel: NotificationChannel, handler: BaseNotificationHandler):
        """ÏïåÎ¶º Ìï∏Îì§Îü¨ Ï∂îÍ∞Ä"""
        self.handlers[channel] = handler
        logger.info(f"Added {channel.value} notification handler")
    
    def set_enabled_levels(self, levels: List[NotificationLevel]):
        """ÌôúÏÑ±ÌôîÌï† ÏïåÎ¶º Î†àÎ≤® ÏÑ§Ï†ï"""
        self.enabled_levels = levels
    
    async def send_alert(self, alert: ErrorAlert, channels: List[NotificationChannel] = None):
        """ÏïåÎ¶º Î∞úÏÜ°"""
        # Î†àÎ≤® ÌôïÏù∏
        if alert.level not in self.enabled_levels:
            return
        
        # ÎπàÎèÑ Ï†úÌïú ÌôïÏù∏
        if not self.rate_limiter.should_send(alert):
            logger.debug(f"Alert rate limited: {alert.title}")
            return
        
        # Î∞úÏÜ°Ìï† Ï±ÑÎÑê Í≤∞Ï†ï
        target_channels = channels or list(self.handlers.keys())
        
        # Î™®Îì† Ï±ÑÎÑêÏóê ÎπÑÎèôÍ∏∞ Î∞úÏÜ°
        tasks = []
        for channel in target_channels:
            if channel in self.handlers:
                handler = self.handlers[channel]
                tasks.append(self._send_to_handler(handler, alert, channel))
        
        if tasks:
            results = await asyncio.gather(*tasks, return_exceptions=True)
            success_count = sum(1 for result in results if result is True)
            logger.info(f"Alert sent to {success_count}/{len(tasks)} channels: {alert.title}")
    
    async def _send_to_handler(
        self, 
        handler: BaseNotificationHandler, 
        alert: ErrorAlert, 
        channel: NotificationChannel
    ) -> bool:
        """Í∞úÎ≥Ñ Ìï∏Îì§Îü¨Î°ú ÏïåÎ¶º Î∞úÏÜ°"""
        try:
            return await handler.send(alert)
        except Exception as e:
            logger.error(f"Failed to send alert via {channel.value}: {e}")
            return False


# Ï†ÑÏó≠ ÏïåÎ¶º Í¥ÄÎ¶¨Ïûê Ïù∏Ïä§ÌÑ¥Ïä§
notification_manager = NotificationManager()


def setup_notifications():
    """
    ÏïåÎ¶º ÏãúÏä§ÌÖú ÏÑ§Ï†ï
    ÌôòÍ≤Ω Î≥ÄÏàòÎ•º Í∏∞Î∞òÏúºÎ°ú ÏïåÎ¶º Ìï∏Îì§Îü¨Îì§ÏùÑ ÏÑ§Ï†ï
    """
    # Ïù¥Î©îÏùº ÏïåÎ¶º ÏÑ§Ï†ï (ÌôòÍ≤ΩÎ≥ÄÏàòÍ∞Ä ÏûàÎäî Í≤ΩÏö∞)
    if all([
        hasattr(settings, 'SMTP_SERVER'),
        hasattr(settings, 'SMTP_PORT'),
        hasattr(settings, 'SMTP_USERNAME'),
        hasattr(settings, 'SMTP_PASSWORD'),
        hasattr(settings, 'ALERT_EMAIL_FROM'),
        hasattr(settings, 'ALERT_EMAIL_TO')
    ]):
        email_handler = EmailNotificationHandler(
            smtp_server=settings.SMTP_SERVER,
            smtp_port=settings.SMTP_PORT,
            username=settings.SMTP_USERNAME,
            password=settings.SMTP_PASSWORD,
            from_email=settings.ALERT_EMAIL_FROM,
            to_emails=settings.ALERT_EMAIL_TO.split(',') if isinstance(settings.ALERT_EMAIL_TO, str) else settings.ALERT_EMAIL_TO
        )
        notification_manager.add_handler(NotificationChannel.EMAIL, email_handler)
    
    # Slack ÏïåÎ¶º ÏÑ§Ï†ï (ÌôòÍ≤ΩÎ≥ÄÏàòÍ∞Ä ÏûàÎäî Í≤ΩÏö∞)
    if hasattr(settings, 'SLACK_WEBHOOK_URL') and settings.SLACK_WEBHOOK_URL:
        slack_handler = SlackNotificationHandler(
            webhook_url=settings.SLACK_WEBHOOK_URL,
            channel=getattr(settings, 'SLACK_CHANNEL', None)
        )
        notification_manager.add_handler(NotificationChannel.SLACK, slack_handler)
    
    # ÏõπÌõÖ ÏïåÎ¶º ÏÑ§Ï†ï (ÌôòÍ≤ΩÎ≥ÄÏàòÍ∞Ä ÏûàÎäî Í≤ΩÏö∞)
    if hasattr(settings, 'ALERT_WEBHOOK_URL') and settings.ALERT_WEBHOOK_URL:
        webhook_handler = WebhookNotificationHandler(
            webhook_url=settings.ALERT_WEBHOOK_URL,
            headers=getattr(settings, 'ALERT_WEBHOOK_HEADERS', {})
        )
        notification_manager.add_handler(NotificationChannel.WEBHOOK, webhook_handler)
    
    # ÏïåÎ¶º Î†àÎ≤® ÏÑ§Ï†ï
    enabled_levels_str = getattr(settings, 'ALERT_LEVELS', 'HIGH,CRITICAL')
    enabled_levels = [
        NotificationLevel(level.strip().lower()) 
        for level in enabled_levels_str.split(',')
        if level.strip()
    ]
    notification_manager.set_enabled_levels(enabled_levels)
    
    logger.info(f"Notification system setup complete. Handlers: {list(notification_manager.handlers.keys())}")


# Ìé∏Ïùò Ìï®ÏàòÎì§
async def send_error_alert(
    title: str,
    message: str,
    level: NotificationLevel = NotificationLevel.HIGH,
    error_code: str = None,
    request_id: str = None,
    user_info: Dict[str, Any] = None,
    context: Dict[str, Any] = None
):
    """ÏóêÎü¨ ÏïåÎ¶º Î∞úÏÜ° Ìé∏Ïùò Ìï®Ïàò"""
    alert = ErrorAlert(
        title=title,
        message=message,
        level=level,
        error_code=error_code,
        request_id=request_id,
        user_info=user_info,
        context=context
    )
    await notification_manager.send_alert(alert)


async def send_critical_alert(title: str, message: str, **kwargs):
    """ÏπòÎ™ÖÏ†Å ÏóêÎü¨ ÏïåÎ¶º Î∞úÏÜ°"""
    await send_error_alert(title, message, NotificationLevel.CRITICAL, **kwargs)


async def send_security_alert(title: str, message: str, **kwargs):
    """Î≥¥Ïïà Í¥ÄÎ†® ÏïåÎ¶º Î∞úÏÜ°"""
    await send_error_alert(title, message, NotificationLevel.HIGH, **kwargs) 